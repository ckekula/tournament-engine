name: CI/CD Pipeline
on:
  push:
    branches: [devops]

env:
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
  FRONTEND_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/devops-frontend
  BACKEND_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/devops-backend

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Login to Docker Hub
        run: echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin

      - name: Build Frontend
        run: docker build -t $FRONTEND_IMAGE:$GITHUB_SHA -f frontend/Dockerfile frontend/
      - name: Push Frontend
        run: docker push $FRONTEND_IMAGE:$GITHUB_SHA

      - name: Build Backend
        run: docker build -t $BACKEND_IMAGE:$GITHUB_SHA -f backend/Dockerfile backend/
      - name: Push Backend
        run: docker push $BACKEND_IMAGE:$GITHUB_SHA

  cd:
    needs: ci
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Create Jenkins SSH key
        run: |
          echo "${{ secrets.JENKINS_SSH_KEY }}" > jenkins-key.pem
          chmod 600 jenkins-key.pem

      - uses: hashicorp/setup-terraform@v2

      - name: Initialize Terraform and Deploy Jenkins
        run: terraform init && terraform apply -auto-approve
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          TF_VAR_production_ssh_key: ${{ secrets.PRODUCTION_SSH_KEY }}
          TF_VAR_github_sha: ${{ github.sha }}
        timeout-minutes: 15

      - name: Get Jenkins IP
        id: get-jenkins-ip
        run: |
          terraform output -raw jenkins_ip > jenkins_ip.txt
          JENKINS_IP=$(cat jenkins_ip.txt | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+')
          echo "Jenkins IP: $JENKINS_IP"
          echo "::set-output name=jenkins_ip::$JENKINS_IP"

      - name: Wait for Jenkins to be ready
        run: |
          JENKINS_IP=${{ steps.get-jenkins-ip.outputs.jenkins_ip }}
          echo "Waiting for Jenkins to be ready at http://$JENKINS_IP:8080"

          attempts=0
          max_attempts=10
          while [ $attempts -lt $max_attempts ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://$JENKINS_IP:8080/)
            echo "Attempt $attempts/$max_attempts - HTTP status code: $HTTP_CODE"
            
            if [[ "$HTTP_CODE" == "200" || "$HTTP_CODE" == "403" ]]; then
              echo "Jenkins is responding! Ready to proceed."
              break
            fi
            
            attempts=$((attempts+1))
            echo "Waiting 5 seconds..."
            sleep 10
          done

          if [ $attempts -eq $max_attempts ]; then
            echo "Timed out waiting for Jenkins to respond"
            exit 1
          fi

      - name: Trigger Jenkins deployment job
        run: |
          JENKINS_IP=${{ steps.get-jenkins-ip.outputs.jenkins_ip }}
          echo "Triggering deployment on Jenkins at: http://$JENKINS_IP:8080"

          # Fetch the Jenkins crumb (CSRF token) and store both parts separately
          CRUMB_RESPONSE=$(curl -s --user "admin:admin" "http://$JENKINS_IP:8080/crumbIssuer/api/json")
          CRUMB_FIELD=$(echo $CRUMB_RESPONSE | jq -r .crumbRequestField)
          CRUMB_VALUE=$(echo $CRUMB_RESPONSE | jq -r .crumb)

          echo "Using crumb: $CRUMB_FIELD:$CRUMB_VALUE"

          # Trigger the job with the crumb in headers
          curl -X POST "http://$JENKINS_IP:8080/job/deploy/buildWithParameters" \
            --user "admin:admin" \
            -H "$CRUMB_FIELD: $CRUMB_VALUE" \
            --data-urlencode "FRONTEND_TAG=$GITHUB_SHA" \
            --data-urlencode "BACKEND_TAG=$GITHUB_SHA" \
            --data-urlencode "PRODUCTION_IP=${{ secrets.PRODUCTION_EC2_IP }}"

      - name: Wait for Deployment to complete
        run: |
          sleep 60
          echo "Verifying deployment..."
          if curl -s http://${{ secrets.PRODUCTION_EC2_IP }}; then
            echo "Deployment successful!"
          else
            echo "Deployment verification failed"
            exit 1
          fi

  destroy:
    runs-on: ubuntu-latest
    needs: cd
    steps:
      - name: Destroy Jenkins after deployment
        if: always()
        run: terraform destroy -auto-approve
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          TF_VAR_production_ssh_key: ${{ secrets.PRODUCTION_SSH_KEY }}
          TF_VAR_github_sha: ${{ github.sha }}
