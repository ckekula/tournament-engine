name: CI/CD Pipeline
on:
  push:
    branches: [cicd]

env:
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
  FRONTEND_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/devops-frontend
  BACKEND_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/devops-backend

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Login to Docker Hub
        run: echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin

      - name: Build Frontend
        run: docker build -t $FRONTEND_IMAGE:$GITHUB_SHA -f frontend/Dockerfile frontend/
      - name: Push Frontend
        run: docker push $FRONTEND_IMAGE:$GITHUB_SHA

      - name: Build Backend
        run: docker build -t $BACKEND_IMAGE:$GITHUB_SHA -f backend/Dockerfile backend/
      - name: Push Backend
        run: docker push $BACKEND_IMAGE:$GITHUB_SHA

  cd:
    needs: ci
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Create Jenkins SSH key
        run: |
          echo "${{ secrets.JENKINS_SSH_KEY }}" > jenkins-key.pem
          chmod 600 jenkins-key.pem

      - uses: hashicorp/setup-terraform@v2

      - name: Initialize Terraform and Deploy Jenkins
        run: terraform init && terraform apply -auto-approve
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          TF_VAR_production_ssh_key: ${{ secrets.PRODUCTION_SSH_KEY }}
          TF_VAR_github_sha: ${{ github.sha }}
        timeout-minutes: 15

      - name: Get Jenkins IP
        id: get-jenkins-ip
        run: |
          terraform output -raw jenkins_ip > jenkins_ip.txt
          JENKINS_IP=$(cat jenkins_ip.txt | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+')
          echo "Jenkins IP: $JENKINS_IP"
          echo "::set-output name=jenkins_ip::$JENKINS_IP"

      - name: Wait for Jenkins to be ready
        run: |
          echo "Waiting for Jenkins to be fully initialized..."
          sleep 60
          JENKINS_IP=${{ steps.get-jenkins-ip.outputs.jenkins_ip }}
          for i in {1..10}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://$JENKINS_IP:8080)
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "403" ]; then
              echo "Jenkins is ready!"
              break
            fi
            echo "Jenkins not ready yet, waiting... (attempt $i/10)"
            sleep 30
          done

      - name: Get Jenkins admin password
        run: |
          JENKINS_IP=${{ steps.get-jenkins-ip.outputs.jenkins_ip }}
          JENKINS_ADMIN_PASSWORD=$(ssh -o StrictHostKeyChecking=no -i jenkins-key.pem ubuntu@$JENKINS_IP "cat /home/ubuntu/jenkins_admin_password.txt")
          echo "jenkins_password=$JENKINS_ADMIN_PASSWORD" >> $GITHUB_OUTPUT
        id: jenkins-password

      - name: Trigger Jenkins job
        run: |
          JENKINS_IP=${{ steps.get-jenkins-ip.outputs.jenkins_ip }}
          JENKINS_ADMIN_PASSWORD=${{ steps.jenkins-password.outputs.jenkins_password }}
          PRODUCTION_IP=${{ secrets.PRODUCTION_IP }}

          echo "Triggering Jenkins job..."
          echo "Jenkins IP: $JENKINS_IP"
          echo "Jenkins Admin Password: $JENKINS_ADMIN_PASSWORD"
          echo "Production IP: $PRODUCTION_IP"

          echo "Listing Jenkins jobs:"
          curl -v -u admin:$JENKINS_ADMIN_PASSWORD http://$JENKINS_IP:8080/api/json?tree=jobs[name] || echo "Failed to list jobs"
          echo "Triggering Jenkins job..."

          curl -X POST http://$JENKINS_IP:8080/job/deployment/buildWithParameters \
            -u admin:$JENKINS_ADMIN_PASSWORD \
            --data-urlencode "FRONTEND_TAG=$GITHUB_SHA" \
            --data-urlencode "BACKEND_TAG=$GITHUB_SHA" \
            --data-urlencode "PRODUCTION_IP=$PRODUCTION_IP"
            
          echo "Jenkins job triggered!"

          # Wait for job to start
          sleep 15

          # Get the build number of the triggered job
          BUILD_NUMBER=$(curl -s -u admin:$JENKINS_ADMIN_PASSWORD http://$JENKINS_IP:8080/job/deployment/lastBuild/api/json | grep -o '"number":[0-9]*' | grep -o '[0-9]*')
          echo "Jenkins build number: $BUILD_NUMBER"

          # Get console output
          echo "Getting console output for build #$BUILD_NUMBER:"
          curl -v -s -u admin:$JENKINS_ADMIN_PASSWORD http://$JENKINS_IP:8080/job/deployment/$BUILD_NUMBER/consoleText | head -n 50 || echo "Failed to get console output"

            if [ "$RESULT" = "SUCCESS" ]; then
              echo "Deployment successful!"
              break
            elif [ "$RESULT" = "FAILURE" ]; then
              echo "Deployment failed! Getting console output:"
              curl -s -u admin:$JENKINS_ADMIN_PASSWORD http://$JENKINS_IP:8080/job/deployment/$BUILD_NUMBER/consoleText | tail -n 100
              exit 1
            elif [ "$RESULT" = "ABORTED" ]; then
              echo "Deployment was aborted!"
              exit 1
            else
              echo "Deployment still in progress, waiting... (attempt $i/30)"
              if [ $i -eq 15 ]; then
                echo "Showing build console output at halfway point:"
                curl -s -u admin:$JENKINS_ADMIN_PASSWORD http://$JENKINS_IP:8080/job/deployment/$BUILD_NUMBER/consoleText | tail -n 50
              fi
              sleep 20
            fi
          done

      # - name: Destroy Jenkins Infrastructure
      #   if: always()
      #   run: terraform destroy -auto-approve
      #   env:
      #     AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      #     AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      #     TF_VAR_dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
      #     TF_VAR_production_ssh_key: ${{ secrets.PRODUCTION_SSH_KEY }}
      #     TF_VAR_github_sha: ${{ github.sha }}
