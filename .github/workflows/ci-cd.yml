name: CI/CD Pipeline
on:
  push:
    branches: [devops]

env:
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
  FRONTEND_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/devops-frontend
  BACKEND_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/devops-backend

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Login to Docker Hub
        run: echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin

      - name: Build Frontend
        run: docker build -t $FRONTEND_IMAGE:$GITHUB_SHA -f frontend/Dockerfile frontend/
      - name: Push Frontend
        run: docker push $FRONTEND_IMAGE:$GITHUB_SHA

      - name: Build Backend
        run: docker build -t $BACKEND_IMAGE:$GITHUB_SHA -f backend/Dockerfile backend/
      - name: Push Backend
        run: docker push $BACKEND_IMAGE:$GITHUB_SHA

  cd:
    needs: ci
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Create Jenkins SSH key
        run: |
          echo "${{ secrets.JENKINS_SSH_KEY }}" > jenkins-key.pem
          chmod 600 jenkins-key.pem

      - uses: hashicorp/setup-terraform@v2

      - name: Initialize Terraform and Deploy Jenkins
        run: terraform init && terraform apply -auto-approve
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          TF_VAR_production_ssh_key: ${{ secrets.PRODUCTION_SSH_KEY }}
          TF_VAR_github_sha: ${{ github.sha }}
        timeout-minutes: 15

      - name: Get Jenkins IP
        id: terraform
        run: |
          echo "jenkins_ip=$(terraform output -raw jenkins_ip)" >> $GITHUB_OUTPUT

      - name: Use the IP
        run: |
          echo "Jenkins IP: ${{ steps.terraform.outputs.jenkins_ip }}"

      - name: Wait for Jenkins to be ready
        run: |
          JENKINS_IP=${{ steps.get-jenkins-ip.outputs.jenkins_ip }}
          echo "Waiting for Jenkins to be ready at http://$JENKINS_IP:8080"

          attempts=0
          max_attempts=30
          while [ $attempts -lt $max_attempts ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://$JENKINS_IP:8080/)
            echo "Attempt $attempts/$max_attempts - HTTP status code: $HTTP_CODE"
            
            if [[ "$HTTP_CODE" == "200" || "$HTTP_CODE" == "403" ]]; then
              echo "Jenkins is responding! Ready to proceed."
              break
            fi
            
            attempts=$((attempts+1))
            echo "Waiting 10 seconds..."
            sleep 10
          done

          if [ $attempts -eq $max_attempts ]; then
            echo "Timed out waiting for Jenkins to respond"
            exit 1
          fi

      - name: Trigger Jenkins deployment job
        run: |
          JENKINS_IP=${{ steps.get-jenkins-ip.outputs.jenkins_ip }}
          echo "Triggering deployment on Jenkins at: http://$JENKINS_IP:8080"
          curl -X POST "http://$JENKINS_IP:8080/job/deploy/buildWithParameters" \
            --user admin:admin \
            --data-urlencode "FRONTEND_TAG=$GITHUB_SHA" \
            --data-urlencode "BACKEND_TAG=$GITHUB_SHA" \
            --data-urlencode "PRODUCTION_IP=${{ secrets.PRODUCTION_EC2_IP }}"

      - name: Wait for Deployment to complete
        run: |
          sleep 60
          echo "Verifying deployment..."
          if curl -s http://${{ secrets.PRODUCTION_EC2_IP }}; then
            echo "Deployment successful!"
          else
            echo "Deployment verification failed"
            exit 1
          fi

      - name: Debug Jenkins logs
        if: failure()
        run: |
          JENKINS_IP=$(cat jenkins_ip.txt)
          echo "Jenkins logs:"
          ssh -i jenkins-key.pem -o StrictHostKeyChecking=no ubuntu@$JENKINS_IP "sudo docker logs jenkins --tail 100"

      - name: Test Jenkins from inside EC2
        if: failure()
        run: |
          JENKINS_IP=$(cat jenkins_ip.txt)
          ssh -i jenkins-key.pem -o StrictHostKeyChecking=no ubuntu@$JENKINS_IP "curl -v http://localhost:8080/ || echo 'Failed to connect locally'"

      - name: Manual verification
        if: failure()
        run: |
          JENKINS_IP=$(cat jenkins_ip.txt)
          ssh -i jenkins-key.pem -o StrictHostKeyChecking=no ubuntu@$JENKINS_IP "
            echo 'Checking if Jenkins home exists and has content...'
            ls -la /var/jenkins_home/
            
            echo 'Checking Docker container status...'
            docker ps -a
            
            echo 'Checking Jenkins process inside container...'
            docker exec jenkins ps aux | grep jenkins
            
            echo 'Checking what ports are listening inside container...'
            docker exec jenkins cat /proc/net/tcp | grep ':1F90' # Hex for 8080
          "

  destroy:
    runs-on: ubuntu-latest
    needs: cd
    steps:
      - name: Destroy Jenkins after deployment
        if: always()
        run: terraform destroy -auto-approve
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          TF_VAR_production_ssh_key: ${{ secrets.PRODUCTION_SSH_KEY }}
          TF_VAR_github_sha: ${{ github.sha }}
